## IDEA mac 快捷键

- 格式化代码：==cmd+opt+L==
- 多行注释：==cmd+opt+/==或者==cmd+shift+/==
- 查看参数调用情况：==cmd+p==
- 抽取代码为方法：==cmd+opt+m==
- 批量修改变量名：==shift+f6==
- 对象接收：==cmd+opt+v==或者==.var==
- 包裹代码块：==cmd+opt+t==
- 全局查找（nevigate）：==shift+shift==
- 自动生成getset方法：==cmd+n==或者==ctrl+return==
- 向下复制一行：==cmd+d==
- 竖排选中：==opt不松==
- 跟进：==cmd+b==
- 接口的实现类：==cmd+opt+b==
- 返回：==cmd+opt+左==或者==cmd+[==
- 变量切割：==opt+return==
- 整行移动：==shift+opt+上下==
- 撤销：==cmd+shift+z==
- run：==ctrl+shift+r==
- debug：==ctrl+shift+d==
-  重写方法：==ctrl+o==
-  显示当前类的所有方法：==cmd+f12==或者==cmd+7==
-  查看变量的值（调试中）：==cmd+f8==
-  xml标签自闭合：==opt+shift+return==
-  xml标签展开：==opt+return==
-  排除maven依赖：==shift+fn+delete==
-  查看类的实现：==ctrl+H==
-  查看方法调用者：==ctrl+alt+H==
-  大小写转换：==cmd+shift+u==

---

## IDEA 代码模板

- 主函数：==psvm、main==
- 输出语句：==sout==
- 输出占位语句：==souf（使用%s占位）==
- 循环：==fori==
- 倒序遍历：==forr==
- 对象接收：==var==
- 增强for：iter

---

## String类常用方法

- 提取字符：==chatAt==
- 分割字符：==substring==
- 替换：==replace==
- 生成字符数组：==tochararray==
- 忽略大小写的比较：==equalsIgnoreCase==

### StringBuilder类

- 添加：==append==
- 反转：==reverse==

### Stringjoiner类

- 构造：==new Stringjoiner("---")==或者==new Stringjoiner(", ", "[","]" )==
- 添加：==add==

---

## 概念

- 字面量
- JavaBean（插件：PTG）
- OGNL对象导航图
- 全类名、全限定名

---

## Tips

1. 在一条语句中，可以定义多个变量，影响阅读，不推荐

==int a = 10, b = 20, c = 20,d = 20;==

2. float -> F

   long -> L

3. project - module - package - class

   JDK - JRE - JVM

4. 隐式转换：byte - short - int - long - float - double

   byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算。

5. ++a：先自增，再参与计算

   a++：先参与计算，再自增

6. &&、||：短路运算符：前面满足条件，不计算后面，提高效率。所以一般不用&、|

7. if后的语句如果只有一条，可以不写大括号，但是一般不要省略。

8. 布尔类型判断不要写==if(flag == true)==，直接判断==if(flag)==

9. switch语句不写break会发生case穿透，有时可以对其进行利用。

   在JDK12的新特性：

   > switch (week) {
   >     case 1, 2, 3, 4, 5 -> System.out.println("工作日");
   >     case 6, 7 -> System.out.println("休息日");
   >     default -> System.out.println("没有这个星期");
   > }

​		JDK14: 对switch的结果整体赋值：

> String text = switch(day){
>
> case MON, TUE, WEN -> "上半周";
>
> case THU, FRI -> "下半周";
>
> case SAT, SUN -> "周末";
>
> }; 

10. 知道循环次数或者循环范围，用for。

    不知道循环次数和循环范围，但知道循环的结束条件，用while。

    一般不用do...while

11. 数组的定义：

    ==int [] array==或者==int array []==，一般用第一种

    静态初始化：==int[] arr = new int[]{11,22,33};==，一般省略为==int[] arr ={11,22,33};==

    动态初始化：==int[] arr = new int[3]==

12. 方法：

```java
public static void method (    ) {
  	// 方法体;
  }
```

​		方法重载只看传入参数的位置和类型，和方法的返回无关

13. 类：

    ```java
    public class Phone {
        //成员变量
        private String brand;
    
        //成员方法
        public void call() {   
           System.out.println("打电话");
        }
    }
    ```

    如果定义了构造方法，系统将不再提供默认的构造方法

    无论是否使用，都手工书写无参数构造方法

14. 创建字符串的方式：

    ```String s = “abc”；直接赋值```
    
    检查字符串常量池中有没有字符串abc，如果有，不会创建新的，而是直接复用。如果没有abc，才会创建一个新的
    
    ```String s1 = new String（“abc”）；```
    
    通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同

15. 对于基本数据类型：==比的是具体的数值是否相等。

    对于引用数据类型：==比的是地址值是否相等。

16. 集合：长度可以变化，只能存储引用数据类型。

    添加基本数据类型时，需要使用其对应的包装类型（jdk5后自动装箱）

17. Scanner:

    第一个细节

    > next(), nextLine()接收任意数据，但是都返回字符串
    >
    > nextInt()接收整数，录入小数或其他字母会报错
    >
    > nextDouble()接收整数和小数，但是都返回小数，录入字母会报错

    第二个细节

    > next（），nextInt（），nextDouble（）在接收数据的时候，会遇到空格，回车，制表符其中一个就会停止接收数据，但是剩余的数据还在内存中，会在下次被接收
    >
    > nextLine（）方法是把一整行全部接收完毕

​		第三个细节

> 上述两套方案不能混用，否则会导致nextLine接收不到数据，如果想要整数，可以先接收，再使用Integer.parseInt进行类型转换

18. 退出程序：

    System.exit(0) 停止虚拟机运行

    break loop 退出循环（给循环命名为loop，仅使用break则跳出单层switch）

19. ```
    //开发细节：先验证格式是否正确，再验证是否唯一
    //         因为在以后所有的数据，都是存在数据库中，如果我们要校验，需要使用到网络资源。
    ```

20. ```
    //封装思想的应用：
    //我们可以把一些零散的数据，封装成一个对象
    //以后传递参数的时候，只要传递一个整体就可以了，不需要管这些零散的数据。
    ```

21. 静态变量是随着类的加载而加载的，优先于对象出现

    所有对象==共享==

    可以用类名调用，也可以用对象名调用，推荐使用类名调用

22. 静态方法多用于测试类或工具类中，javabean中很少使用

    javabean类：用来描述一类事物的类

    测试类：用来检查其他类是否书写正确，一般带有main方法，是程序的主入口

    工具类：不是用来描述一类事物，而是帮我们完成一些事情的类

23. 工具类：

    类名见名知意，私有化构造方法，方法全部定义为静态

24. 静态方法中没有this关键字（非静态的方法中隐藏了一个当前类的this参数，由虚拟机赋值）静态方法中，只能访问静态

    非静态方法可以访问所有

25. 当类与类之间，存在相同（共性）的内容，并满足子类是父类的一种，就可以考虑使用继承，来优化代码。

26. java中只支持单继承，不支持多继承，但是支持多层继承

27. 一个java文件中只写一个类

28. public修饰的类的类名与文件名一致

29. 栈与方法有关，堆与new有关，方法区与字节码文件有关

30. 虚方法表：非private，非static，非final

    只有父类中的虚方法才能被子类继承

31. 子类不能继承父类的构造方法。

    值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。

32. 成员变量的访问特点：就近原则（先在局部位置找，本类成员位置找，父类成员位置找，逐级往上）

33. 在子类中，最多只能调用一个super，super.super会报错

34. 成员方法的访问特点：直接调用满足就近原则，super调用直接访问父类

35. @Override是放在重写后的方法上，校验子类重写时语法是否正确

36. 方法重写的本质：覆盖虚方法表中的方法

37. 方法重写的注意事项和要求：

    > 1 重写方法的名称、形参列表必须与父类中的一致
    >
    > 2 子类重写父类方法时，访问权限子类必须大于等于父类（暂时了解：空着不写 < protected < public）
    >
    > 3 子类重写父类方法时，返回值类型子类必须小于等于父类
    >
    > 4 **建议：重写的方法尽量和父类保持一致**
    >
    > 5 只有被添加到虚方法表中的方法才能被重写

38. 构造方法的访问特点：

    > 子类不能继承父类的构造方法，但是可以通过super调用
    >
    > 子类构造方法的第一行，有一个默认的super()
    >
    > 默认先访问父类中无参的构造方法，再执行自己。
    >
    > 如果想要访问父类有参构造，必须手动书写。

39. this：理解为一个变量，表示当前方法调用者的地址值

super：代表父类存储空间

40. 使用this()调用本类的构造方法时，虚拟机不会再添加super()

41. 多态的前提：有继承/实现关系

    有父类引用指向子类对象

    有方法重写

42. 多态调用成员变量：编译看左边，运行也看左边

    多态调用成员方法：编译看左边，运行看右边

43. 多态的优势：方法中，使用wqod型作为参数，可以接收所有子类对象

    多态的弊端：不能使用子类的特有功能

    强制类型转换：可以转换成真正的子类类型，从而调用子类独有功能

    转换类型与真实对象类型不一致会报错

44. 转换的时候用instanceof关键字判断：

    ```java
            if(a instanceof Dog){
                Dog d = (Dog) a;
                d.lookHome();
            }else if(a instanceof Cat){
                Cat c = (Cat) a;
                c.catchMouse();
            }else{
                System.out.println("没有这个类型，无法转换");
            }
    ```

    jdk14新特性：

    ```java
            if(a instanceof Dog d){
                d.lookHome();
            }else if(a instanceof Cat c){
                c.catchMouse();
            }else{
                System.out.println("没有这个类型，无法转换");
            }
    ```

45. final修饰方法：表明该方法是最终方法，不能被重写

    修饰类：表明该类是最终类，不能被继承

    修饰变量：叫做常量，只能被赋值一次

46. 常量命名规则：单个单词全用大写，多个单词用下划线隔开

47. 权限修饰符：实际开发中，一般只用private和public

    成员变量私有，方法公开

    特例：如果方法中的代码是抽取其他方法中共性代码，这个方法一般也私有

48. 局部代码块：提前结束变量的生命周期

    构造代码块：抽取构造方法中的重复代码（先执行构造方法块再执行构造方法）

    静态代码块：数据的初始化（随着类的加载而加载，并且只执行一次）

49. 构造代码块不够灵活，如果只有部分构造方法有重复代码，用构造代码块也会全部执行。

    可以将重复部分写在一个构造方法中用this(调用)，或者将重复代码抽取成为公共方法

50. 抽象类：

    抽取共性时，无法确定方法体，就把方法定义为抽象的

    强制让子类按照某种格式重写

    抽象方法所在的类，必须是抽象类

    抽象类不能实例化，可以有构造方法（给子类对象赋值用的）

    抽象类的子类要么重写所有抽象方法，要么是抽象类

51. 接口就是一种规则，是对行为的抽象

    接口的实现类要么重写所有抽象方法，要么是抽象类

    可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口

52. 接口中成员的特点：

    成员变量：只能是常量，默认修饰符 public static final

    构造方法：没有

    成员方法：只能是抽象方法，默认修饰符public abstract

    （jdk8新特性：接口中可以定义有方法体的方法）

    （jdk9新特性：接口中可以定义私有方法）

53. 实现多个接口时，如果有重名方法，只需要重写一次即可

54. 接口和接口之间可以单继承，也可以多继承，如果实现类实现了最下面的子接口，那么就需要重写体系中所有的抽象方法

55. 细节：如果不想让外界去直接创建对象，或者创建这个类的对象是没有意义的，可以把一个类定义为抽象类

56. 接口的默认方法（jdk8）：解决接口升级问题

    默认方法不是抽象方法，不强制重写，如果重写则去掉default关键字

    public可以省略，default不能省略

    如果实现了多个接口，多个接口中存在同名的默认方法，子类就必须对该方法进行重写

57. 接口的静态方法（jdk8）

    public可以省略，static不能省略

    静态方法只能通过接口名调用，不能通过实现类或对象名调用

58. 接口的私有方法（jdk9）：重复代码只为当前接口提供服务，不需要外类访问

    普通的私有方法，给默认方法服务

    静态的私有方法，给静态方法服务

59. 接口多态：当一个方法的参数是接口时，可以传递接口所有实现类的对象

60. 适配器设计模式：

    编写中间类XXXAdapter（用abstract修饰），实现对应的接口，对接口中的抽象方法进行空实现

    让真正的实现类继承中间类，并重写需要使用的方法

61. 内部类表示的事物是外部类的一部分，内部类单独出现没有任何意义

    内部内可以直接访问外部类的成员，包括私有

    外部类要访问内部类的成员，必须创建对象

62. jdk16新特性：在成员内部类的里面，可以定义静态变量

63. ```java
    Outer.Inner oi = new Outer().new Inner();
               System.out.println(Outer.this.a);
    ```

64. 静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象

65. ```java
    Outer.Inner oi = new Outer.Inner();//创建静态内部类的对象
    oi.show1();//非静态方法
    Outer.Inner.show2();//静态方法
    ```

66. 局部内部类：将内部类定义在方法里面，类似于方法里面的局部变量

67. 匿名内部类的本质：隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置

    包含了继承或实现、方法重写、创建对象

    如果子类或实现类只用一次，可以用匿名内部类简化代码

68. ```java
            new Swim() {
                @Override
                public void swim() {
                    System.out.println("swim");
                }
            };
    ```

69. 长度固定用数组，长度不固定用集合

70. 相对路径是相对项目而言的，从模块名开始书写

71. 如果一个接口里面没有抽象方法，表示当前接口是一个标记性接口

    Cloneable表示一旦实现，当前类的对象可被克隆，如果没有实现，刚不可被克隆

72. 浅克隆：不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来

    深克隆：基本数据类型拷贝过来，字符串复用，引用数据类型会重新创建新的

73. BigInteger使用valueof时底层对-16～16做了优化，节约内存

    对象一旦创建，里面的数据不能改变，只要参与计算就会创建新的对象

74. BigDecimal: 不建议通过传递double来创建对象，常用传递字符串或者valueof，使用valueof时底层对0～10的整数做了优化

    对象一旦创建，里面的数据不能改变，只要参与计算就会创建新的对象

75. 查表法：让数据跟索引产生对应的关系

76. jdk新增的时间对象都是不可变的

77. 在JDK5的时候提出了一个机制:自动装箱和自动拆箱
    自动装箱:把基本数据类型会自动的变成其对应的包装类
    自动拆箱:把包装类自动的变成其对象的基本数据类型

    在底层，此时还会去自动调用静态方法valueof得到一个Integer对象，只不过这个动作不需要我们自己去操作了。

    结论：在JDK5以后，int和Integer可以看做是同一个东西，因为在内部可以自动转化。

78. 以后我们如果想要键盘录入，不管什么类型，统一使用nextLine，再使用parseXxx方法转换为想要的数据类型
79. 校验时，习惯：会先把异常数据进行过滤，剩下来就是正常的数据。
80. 除基取余和按权展开
81. 
